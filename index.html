<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/black.css" id="theme">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css" id="highlight-theme">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>Regular Expressions</section>
				<section>
					<section>Introduction</section>
					<section>
						<p>A regular expression (also called regex) is a way to work with strings</p>
						<p>You can</p>
						<ul>
							<li>search text a string</li>
							<li>replace substrings in a string</li>
							<li>extract information from a string</li>
						</ul>
						<aside class="notes">
							Almost every programming language implements regular expressions. There are small differences between each implementation, but the general concepts apply almost everywhere.
							JavaScript  is one of the programming languages that have regular expressions support directly built in the language.
							Regular expressions can appear like absolute nonsense to the beginner, and many times also to the professional developer, if one does not invest the time necessary to understand them.
							Cryptic regular expressions are hard to write, hard to read, and hard to maintain/modify.
							But sometimes a regular expression is the only sane way to perform
							The rule of thumb is that simple regular expressions are simple to read and write, while complex regular expressions can quickly turn into a mess if you don’t deeply grasp the basics.
						</aside>
					</section>
				</section>
				<section>
					<section>
						<p>In JavaScript, a regular expression is an object, which can be defined in two ways.</p>
						<p>The first is by instantiating a new RegExp object using the constructor:</p>
						<img data-src="public/1.PNG" alt="">
						<p>The second is using the regular expression literal form:</p>
						<img src="./public/2.PNG" alt="">
						<aside class="notes">
							You know that JavaScript has object literals and array literals? It also has regex literals.
							In the example above, hey is called the pattern. In the literal form it’s delimited by forward slashes, while with the object constructor, it’s not.
							This is the first important difference between the two forms, but we’ll see others later.
						</aside>
					</section>
					<section>
						<h1>How does it work?</h1>
						<p>You can test the regex using RegExp.test(String), which returns a boolean</p>
						<img src="/public/3.PNG" alt="">
						<aside class="notes">
							The regular expression we defined as re1 above is a very simple one. It searches the string hey, without any limitation: the string can contain lots of text, and hey in the middle, and the regex is satisfied. It could also contain just hey, and it will be satisfied as well.
							That’s pretty simple.
							You can test the regex using RegExp.test(String), which returns a boolean:
						</aside>
					</section>
				</section>
				<section>
					<section>
						<h1>Anchoring</h1>
						<img src="public/4.PNG" alt="">
						<aside class="notes">
							matches hey wherever it was put inside the string.
						</aside>
					</section>
					<section>
						<p>The ^ operator</p>
						<img src="public/5.PNG" alt="">
						<p>The $ operator</p>
						<img src="public/6.PNG" alt="">
						<aside class="notes">
							If you want to match strings that start with hey, use the ^ operator:
							If you want to match strings that end with hey, use the $ operator:
						</aside>
					</section>
					<section>
						<p>Combine</p>
						<img src="public/7.PNG" alt="">
						<p>The .* operator</p>
						<img src="public/8.PNG" alt="">
						<aside class="notes">
							To match a string that starts with a substring and ends with another, you can use .*, which matches any character repeated 0 or more times:
						</aside>
					</section>
				</section>
				<section>
					<section>
						<h1>Match items in ranges</h1>
						<p>You can choose to match any character in a range</p>
						<img src="public/9.PNG" alt="">
						<img src="public/10.PNG" alt="">
						<aside class="notes">
							Instead of matching a particular string, you can choose to match any character in a range, like:

							These regexes match strings that contain at least one of the characters in those ranges:
						</aside>
					</section>
					<section>
						<p>Ranges can be combined</p>
						<img src="public/11.PNG" alt="">
						<img src="public/12.PNG" alt="">
					</section>
					<section>
						<h1>Matching a range item multiple times</h1>
						<img src="public/13.PNG" alt="">
						<aside class="notes">
							You can check if a string contains one an only one character in a range, by starting the regex with ^ and ending with the $ char:
						</aside>
					</section>
				</section>
				<section>
					<h1>Negating a pattern</h1>
					<img src="public/14.PNG" alt="">
					<aside class="notes">
						The ^ character at the beginning of a pattern anchors it to the beginning of a string.
Used inside a range, it negates it, so:
					</aside>
				</section>
				<section>
					<h1>Meta characters</h1>
					<ul>
						<li>\d matches any digit, equivalent to [0-9]</li>
						<li>\D matches any character that’s not a digit, equivalent to [^0-9]</li>
						<li>\w matches any alphanumeric character (plus underscore), equivalent to [A-Za-z_0-9]</li>
						<li>\W matches any non-alphanumeric character, anything except [^A-Za-z_0-9]</li>
						<li>\0 matches null</li>
						<li>\n matches a newline character</li>
						<li>\t matches a tab character</li>
						<li>\S matches any character that’s not a whitespace</li>
					</ul>
				</section>
				<section>
					<h1>Regular expressions choices</h1>
					<p>The | operator</p>
					<img src="public/15.PNG" alt="">
					<aside class="notes">
						If you want to search one string or another, use the | operator.
					</aside>
				</section>
				<section>
					<section>
						<h1>Quantifiers</h1>
						<img src="public/16.PNG" alt="">
						<p>The ? operator</p>
						<img src="public/17.PNG" alt="">
						<aside class="notes">
							Say you have this regex, that checks if a string has one digit in it, and nothing else:
You can use the ? quantifier to make it optional, thus requiring zero or one:
						</aside>
					</section>
					<section>
						<h1>+</h1>
						<p>Match one or more (>=1) items</p>
						<img src="public/18.PNG" alt="">
					</section>
					<section>
						<h1>*</h1>
						<p>Match 0 or more (>= 0) items</p>
						<img src="public/19.PNG" alt="">
					</section>
					<section>
						<h1>{n}</h1>
						<p>Match n items</p>
						<img src="public/20.PNG" alt="">
					</section>
					<section>
						<h1>{n,m}</h1>
						<p>Match between n and m times:</p>
						<img src="public/21.PNG" alt="">
						<p>At least n items</p>
						<img src="public/22.PNG" alt="">
						<aside class="notes">
							m can be omitted to have an open ending to have at least n items:
						</aside>
					</section>
				</section>
				<section>
					<h1>Optional items</h1>
					<img src="public/23.PNG" alt="">
					<aside class="notes">
						Following an item with ? makes it optional:
					</aside>
				</section>
				<section>
					<section>
						<h1>Groups</h1>
						<p>Using parentheses, you can create groups of characters: (...)</p>
						<img src="public/24.PNG" alt="">
						<img src="public/25.PNG" alt="">
						<aside class="notes">
							Using round brackets, you can create groups of characters: (...)
This example matches exactly 3 digits followed by one or more alphanumeric characters:
						</aside>
					</section>
					<section>
						<h1>Capturing Groups</h1>
						<p>A very cool feature of regular expressions is the ability to capture parts of a string, and put them into an array.
You can do so using Groups, and in particular Capturing Groups.</p>
						<ul>
							<li>String.match(RegExp)</li>
							<li>RegExp.exec(String)</li>
						</ul>
						<aside class="notes">
							So far, we’ve seen how to test strings and check if they contain a certain pattern.
A very cool feature of regular expressions is the ability to capture parts of a string, and put them into an array.
You can do so using Groups, and in particular Capturing Groups.
By default, a Group is a Capturing Group. Now, instead of using RegExp.test(String), which just returns a boolean if the pattern is satisfied, we use one of
						</aside>
					</section>
					<section>
						<p>If there is no match, it returns null</p>
						<img src="public/26.PNG" alt="">
						<img src="public/27.PNG" alt="">
						<aside class="notes">
They are exactly the same, and return an Array with the whole matched string in the first item, then each matched group content.
						</aside>
					</section>
					<section>
						<h1>Optional groups</h1>
						<img src="public/28.PNG" alt="">
						<aside class="notes">
							A capturing group can be made optional by using (...)?. If it’s not found, the resulting array slot will contain undefined:
						</aside>
					</section>
					<section>
						<h1>Using match and exec without groups</h1>
						<img src="public/29.PNG" alt="">
						<aside class="notes">
							There is a difference with using match and exec without groups: the first item in the array is not the whole matched string, but the match directly:
						</aside>
					</section>
					<section>
						<h1>Noncapturing Groups</h1>
						<p>If you need a way to ignore some groups in the resulting array</p>
						<img src="public/30.PNG" alt="">
						<aside class="notes">
							Since by default groups are Capturing Groups, you need a way to ignore some groups in the resulting array. This is possible using Noncapturing Groups, which start with an (?:...)
						</aside>
					</section>
				</section>
				<section>
					<h1>Flags</h1>
					<ul>
						<li>g: matches the pattern multiple times</li>
						<li>i: makes the regex case insensitive</li>
						<li>m: enables multiline mode</li>
						<li>s: (new in ES2018) short for single line,</li>
						<li>u: enables support for unicode </li>
					</ul>
					<img src="public/31.PNG" alt="">
					<img src="public/32.PNG" alt="">
				</section>
				<section>
					<h1>Inspecting a regex</h1>
					<p>Given a regex, you can inspect its properties</p>
					<ul>
						<li>source the pattern string</li>
						<li>multiline true with the m flag</li>
						<li>global true with the g flag</li>
						<li>ignoreCase true with the i flag</li>
						<li>lastIndex</li>
					</ul>
					<img src="public/33.PNG" alt="">
				</section>
				<section>
					<h1>Escaping</h1>
					<ul>
						<li>\</li>
						<li>/</li>
						<li>[]</li>
						<li>()</li>
						<li>{}</li>
						<li>?</li>
						<li>+</li>
						<li>*</li>
						<li>|</li>
						<li>.</li>
						<li>^</li>
						<li>$</li>
					</ul>
					<img src="public/34.PNG" alt="">
					<aside class="notes">
						They are special because they are control characters that have a meaning in the regular expression pattern, so if you want to use them inside the pattern as matching characters, you need to escape them, by prepending a backslash:
					</aside>
				</section>
				<section>
					<section>
						<h1>Replacing using Regular Expressions</h1>
						<p>The String object in JavaScript has a replace() method, which can be used without regular expressions to perform a single replacement on a string</p>
						<img src="public/35.PNG" alt="">
						<img src="public/36.PNG" alt="">
						<aside class="notes">
							We already saw how to check if a string contains a pattern.
We also saw how to extract parts of a string to an array, matching a pattern.
Let’s see how to replace parts of a string based on a pattern.
The String object in JavaScript has a replace() method, which can be used without regular expressions to perform a single replacement on a string:
						</aside>
					</section>
					<section>
						<p>Using the g flag is the only way to replace multiple occurrences in a string</p>
						<img src="public/37.PNG" alt="">
						<img src="public/38.PNG" alt="">
					</section>
					<section>
						<img src="public/39.PNG" alt="">
						<aside class="notes">
							Instead of using a string you can use a function, to do even fancier things. It will receive a number of arguments like the one returned by String.match(RegExp) or RegExp.exec(String), with a number of arguments that depends on the number of groups:
						</aside>
					</section>
				</section>
			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});
		</script>
	</body>
</html>
